---
date: 28.10.2020
linktitle: Запуск java в Kubernetes. Ограничение по памяти
title: Запуск java в Kubernetes. Ограничение по памяти
weight: 10
---

# Флаги Java для запуска в Kubernetes с ограничением памяти

## Учет лимитов на памяти

Так как приложения в Kubernetes запускается, как правило, с установленным ограничением на потребление памати, то JVM об этом тоже лучше уведомить.

Для этого рекомендуется включить поддержку запуска в контейнерах, тогда JVM будет видеть не все ресурсы кластера, а только установленные ограничения:

`-XX:+UseContainerSupport`

| Значение | Применение | По умолчанию |
|---|---|---|
| -XX:-UseContainerSupport | Выключено |  |
| -XX:+UseContainerSupport | Включено | Да |


После этого стоит указать какой процент от лимитов JVM может использовать:

`-XX:MaxRAMPercentage=80.0`

| Лимит на контейнер 	| Максимальный размер хипа в % 	|
|--------------------	|------------------------------	|
| Меньше 1 GB        	| 50%                          	|
| 1 GB - 2 GB        	| - 512 MB                     	|
| Больше 2 GB        	| 75%                          	|


#### Как не стоит ограничивать память:

Привычные для многих флаги XMX и XMS работать будут, но часто приводят к неправильному трактованию. 
Я замечал частую ошибку, что XMX = Лимит на контейнер. 
Такой подход не учитывает, что кроме Хипа который регулируется параметром XMX есть еще много типов выделяемой JVM памяти, так и память базового образа в котором запущено приложение.

#### Подбор процента потреблячемой памяти:

Тут все индивидуально и есть значения по умолчанию. 
Таблица.
Надо понимать, что если с Java на поде запускаются еще какие-то процессы, такие как профилировщики, отладчики и т.п. , то вероятность поймать OOM  будет больше.

#### Что происходит если не ограничивать память:

На Linux ничего плохого не произойдет, так как параметр UseContainerSupport по умолчанию включен.
Если он выключен или выставлен параметр XMX = размеру лимита, что приложение убьет OOM Killer.

# GC
 
После запуска JAVA в контейнере можно проверить, какой GC был выбран
`java -XX:+PrintCommandLineFlags`

Если приложение запущено на лимитах меньше чем 2000m (2 ядра) CPU и 1954Mi (2048 мегабайт), то будет выбран клиентский режим работы и соответственно SerialGC.

https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/999dbd4192d0f819cb5224f26e9e7fa75ca6f289/src/hotspot/share/runtime/os.cpp#L1627

Чтобы это исправить, достаточно явно указать запуск в серверном режиме:

`-XX:+AlwaysActAsServerClassMachine`

Так что, если вы наблюдаете на своем приложение stop-the-world паузы больше чем 10ms проверьте, какой у вас сейчас работает GC.





